<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <title>ESP32 Graphen</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="/wifi/css/materialize.min.css" rel="stylesheet">
    <link href="/wifi/css/material-icons.css" rel="stylesheet">

    <style>
        body {
            padding: 2rem;
        }

        .graph-card {
            margin-bottom: 1.5rem;
        }

        .graph-canvas {
            width: 100%;
            height: 300px;
        }
    </style>

    <script src="/wifi/js/chart.umd.min.js"></script>
</head>

<body>
    <h4>ðŸ“ˆ Live Graphen</h4>
    <div id="graphs"></div>

    <script src="/wifi/js/materialize.min.js"></script>
    <script>
        const graphsContainer = document.getElementById("graphs");

        const charts = new Map();

        function ensureGraph(graphName) {
            if (charts.has(graphName)) return charts.get(graphName);

            const card = document.createElement("div");
            card.className = "card graph-card";

            const content = document.createElement("div");
            content.className = "card-content";

            const title = document.createElement("span");
            title.className = "card-title";
            title.textContent = graphName;

            const canvas = document.createElement("canvas");
            canvas.className = "graph-canvas";

            content.appendChild(title);
            content.appendChild(canvas);
            card.appendChild(content);
            graphsContainer.appendChild(card);

            const ctx = canvas.getContext("2d");
            const chart = new Chart(ctx, {
                type: "line",
                data: { datasets: [] },
                options: {
                    responsive: true,
                    animation: false,
                    parsing: false,
                    normalized: true,
                    scales: {
                        x: { type: "linear", title: { display: true, text: "x" } },
                        y: { title: { display: true, text: "y" } }
                    },
                    plugins: { legend: { display: true } }
                }
            });

            const obj = { chart, datasets: new Map() };
            charts.set(graphName, obj);
            return obj;
        }

        function ensureDataset(graphName, label) {
            const g = ensureGraph(graphName);
            if (g.datasets.has(label)) return g.datasets.get(label);

            const datasetIndex = g.chart.data.datasets.length;
            g.chart.data.datasets.push({
                label: label,
                data: [],        // {x, y}
                borderWidth: 2,
                pointRadius: 0
            });

            g.datasets.set(label, datasetIndex);
            return datasetIndex;
        }

        function setSeries(graphName, label, points) {
            const g = ensureGraph(graphName);
            const idx = ensureDataset(graphName, label);
            g.chart.data.datasets[idx].data = points.map(p => ({ x: p.x, y: p.y }));
            g.chart.update("none");
        }

        function appendPoint(graphName, label, x, y) {
            const g = ensureGraph(graphName);
            const idx = ensureDataset(graphName, label);
            const arr = g.chart.data.datasets[idx].data;

            arr.push({ x, y });
            while (arr.length > 20) arr.shift();

            g.chart.update("none");
        }

        const proto = (location.protocol === "https:") ? "wss" : "ws";
        const wsUrl = `${proto}://${location.host}/ws/graphs`;
        const ws = new WebSocket(wsUrl);

        ws.onopen = () => {
            M.toast({ html: "WebSocket verbunden", classes: "green" });
        };

        ws.onclose = () => {
            M.toast({ html: "WebSocket getrennt", classes: "red" });
        };

        ws.onerror = (e) => {
            console.error("WS error", e);
        };

        ws.onmessage = (ev) => {
            let msg;
            try { msg = JSON.parse(ev.data); }
            catch (e) { return; }

            if (msg.type === "init") {
                setSeries(msg.graph, msg.label, msg.points || []);
            } else if (msg.type === "data") {
                appendPoint(msg.graph, msg.label, msg.x, msg.y);
            } else if (msg.type === "init_done") {
            }
        };

        function startDemo() {
            const start = Date.now();
            let t = 0;

            const histTemp = [];
            const histHum = [];
            for (let i = 0; i < 20; i++) {
                const x = i;
                histTemp.push({ x, y: 20 + Math.sin(i / 3) * 2 });
                histHum.push({ x, y: 50 + Math.cos(i / 4) * 5 });
            }
            setSeries("Wetter", "Temperatur", histTemp);
            setSeries("Wetter", "Luftfeuchte", histHum);

            setInterval(() => {
                t += 1;
                const x = t;
                appendPoint("Wetter", "Temperatur", x, 20 + Math.sin((Date.now() - start) / 1000) * 2);
                appendPoint("Wetter", "Luftfeuchte", x, 50 + Math.cos((Date.now() - start) / 1200) * 5);
                appendPoint("System", "Heap", x, 180000 + Math.sin((Date.now() - start) / 800) * 20000);
            }, 500);
        }
    </script>
</body>

</html>