<!DOCTYPE html>
<html lang="de">

<head>
  <meta charset="UTF-8">
  <title>ESP32 Admin</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="/css/materialize.min.css" rel="stylesheet">
  <link href="/css/material-icons.css" rel="stylesheet">
  <style>
    body {
      padding: 2rem;
      background: #f7f9fc;
    }

    .card-grid {
      display: flex;
      flex-direction: column;
      gap: 1rem;
    }

    .setting-row {
      display: flex;
      align-items: center;
      margin-bottom: 0.75rem;
      gap: 0.75rem;
    }

    .setting-row label {
      min-width: 120px;
      font-weight: 600;
    }

    .setting-row .value-list {
      margin: 0;
      padding-left: 1rem;
    }

    .chip.connected { background-color: #e8f5e9; color: #2e7d32; }
    .chip.disconnected { background-color: #ffebee; color: #c62828; }
  </style>
</head>

<body>
  <h4>‚öôÔ∏è ESP32 Admin</h4>

  <div id="loginBox" style="margin-bottom:1rem; display:none;">
    <div class="card">
      <div class="card-content">
        <span class="card-title">Login</span>
        <div class="row">
          <div class="input-field col s12">
            <input id="adminPw" type="password">
            <label for="adminPw">Admin Passwort</label>
          </div>
        </div>
      </div>
      <div class="card-action">
        <a class="btn" id="loginBtn">Login</a>
      </div>
    </div>
  </div>

  <div id="mainContent" style="display:none;">
    <div style="margin-bottom:1rem; display:flex; gap:0.5rem; align-items:center; flex-wrap: wrap;">
      <span id="wsBadge" class="chip disconnected">WS: getrennt</span>
      <span id="authBadge" class="chip grey lighten-3">Auth: unbekannt</span>
    </div>

    <div id="cardsContainer" class="card-grid"></div>

    <div id="graphsContainer" class="card-grid" style="margin-top:1rem;"></div>

    <div id="dynamicButtons" class="card" style="margin-top:1rem; display:none;">
      <div class="card-content">
        <span class="card-title">Weitere Aktionen</span>
        <div id="dynamicButtonsContainer"></div>
      </div>
    </div>

    <div class="card" style="margin-top:1rem;">
      <div class="card-content">
        <span class="card-title">üêõ WebSocket Debug</span>
        <pre id="wsDebugLog" style="background:#263238; color:#aed581; padding:1rem; border-radius:4px; max-height:400px; overflow-y:auto; font-size:0.85rem; margin:0;"></pre>
      </div>
      <div class="card-action">
        <a class="btn-small red" onclick="document.getElementById('wsDebugLog').textContent = ''">Clear</a>
      </div>
    </div>
  </div>

  <script src="/js/materialize.min.js"></script>
  <script src="/js/chart.umd.min.js"></script>
  <script>
    // --- State ---
    const topicState = {};
    let ws = null;
    let isAuthorized = false;
    const graphCharts = {}; // { graph_name: { chart, datasets: { label: data } } }

    // --- Helpers ---
    const byId = (id) => document.getElementById(id);
    const formatTopic = (t) => t.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());

    function showLogin() {
      byId('loginBox').style.display = 'block';
      byId('mainContent').style.display = 'none';
      byId('authBadge').textContent = 'Auth: erforderlich';
      byId('authBadge').className = 'chip red lighten-4';
    }

    function showMain() {
      byId('loginBox').style.display = 'none';
      byId('mainContent').style.display = 'block';
      byId('authBadge').textContent = 'Auth: ok';
      byId('authBadge').className = 'chip green lighten-4';
    }

    function unwrapField(raw) {
      if (raw && typeof raw === 'object' && !Array.isArray(raw)) {
        // Liste pr√ºfen
        if ('items' in raw && Array.isArray(raw.items)) {
          return { kind: 'list', value: raw.items, raw };
        }
        // Button pr√ºfen
        if ('type' in raw && raw.type === 'button') {
          return { kind: 'button', value: raw.id, raw };
        }
        // Secret pr√ºfen (VarMeta) - leeres Textfeld anzeigen
        if ('type' in raw && raw.type === 'secret') {
          return { kind: 'string', value: '', raw };
        }
        // Verschachteltes Objekt mit 'value' auspacken
        if ('value' in raw) return unwrapField(raw.value);
      }
      if (Array.isArray(raw)) return { kind: 'list', value: raw, raw };
      if (typeof raw === 'boolean') return { kind: 'bool', value: raw, raw };
      if (typeof raw === 'number') return { kind: 'number', value: raw, raw };
      return { kind: 'string', value: raw == null ? '' : String(raw), raw };
    }

    function renderTopics() {
      const container = byId('cardsContainer');
      container.innerHTML = '';

      Object.keys(topicState).sort().forEach((topic) => {
        const data = topicState[topic];
        const card = document.createElement('div');
        card.className = 'card';
        card.dataset.topic = topic;

        const content = document.createElement('div');
        content.className = 'card-content';
        const title = document.createElement('span');
        title.className = 'card-title';
        title.textContent = formatTopic(topic);
        content.appendChild(title);

        const fields = Object.keys(data);
        if (fields.length === 0) {
          const p = document.createElement('p');
          p.textContent = 'Keine Daten verf√ºgbar';
          content.appendChild(p);
        } else {
          fields.forEach((key) => {
            const info = unwrapField(data[key]);
            const row = document.createElement('div');
            row.className = 'setting-row';

            // Check if it's a graph_xy_ring type
            if (info.raw && info.raw.type === 'graph_xy_ring') {
              renderGraph(topic, key, info.raw);
              return; // Skip normal rendering
            }

            // Fallback: alles was nach Button aussieht als Button rendern
            const isButtonKey = key.toLowerCase().includes('button');

            if (info.kind === 'button' || isButtonKey) {
              const btn = document.createElement('a');
              btn.className = 'btn waves-effect waves-light orange';
              btn.style.margin = '0.5rem 0';
              btn.textContent = '‚ñ∂ ' + key.replace(/_/g, ' ');
              btn.onclick = () => triggerButton(topic, key);
              row.appendChild(btn);
            } else if (info.kind === 'list') {
              const label = document.createElement('label');
              label.textContent = key;
              row.appendChild(label);

              const ul = document.createElement('ul');
              ul.className = 'value-list';
              info.value.forEach((item) => {
                const li = document.createElement('li');
                li.textContent = item;
                ul.appendChild(li);
              });
              row.appendChild(ul);
            } else if (info.kind === 'bool') {
              const label = document.createElement('label');
              label.textContent = key;
              row.appendChild(label);

              const toggle = document.createElement('label');
              const input = document.createElement('input');
              input.type = 'checkbox';
              input.checked = !!info.value;
              input.dataset.field = key;
              input.dataset.kind = 'bool';
              const span = document.createElement('span');
              toggle.appendChild(input);
              toggle.appendChild(span);
              row.appendChild(toggle);
            } else {
              const label = document.createElement('label');
              label.textContent = key;
              row.appendChild(label);

              // Text oder Number Input (immer type="text" oder "number", nie "password")
              const input = document.createElement('input');
              input.type = info.kind === 'number' ? 'number' : 'text';
              input.value = info.value;
              input.className = 'browser-default';
              input.dataset.field = key;
              input.dataset.kind = info.kind;
              row.appendChild(input);
            }

            content.appendChild(row);
          });
        }

        const actions = document.createElement('div');
        actions.className = 'card-action';
        const saveBtn = document.createElement('a');
        saveBtn.className = 'btn blue';
        saveBtn.textContent = 'Speichern';
        saveBtn.onclick = () => submitTopicUpdate(topic, card);
        actions.appendChild(saveBtn);

        card.appendChild(content);
        card.appendChild(actions);
        container.appendChild(card);
      });
    }

    function submitTopicUpdate(topic, cardEl) {
      const inputs = cardEl.querySelectorAll('[data-field]');
      const payload = {};
      inputs.forEach((el) => {
        const key = el.dataset.field;
        const kind = el.dataset.kind;
        if (kind === 'bool') {
          payload[key] = el.checked;
        } else if (kind === 'number') {
          const n = parseFloat(el.value);
          payload[key] = isNaN(n) ? 0 : n;
        } else {
          payload[key] = el.value;
        }
      });

      sendUpdate(topic, payload);
    }

    function sendUpdate(topic, data) {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        M.toast({ html: 'WebSocket nicht verbunden', classes: 'red' });
        return;
      }
      const msg = { topic, data };
      ws.send(JSON.stringify(msg));
      M.toast({ html: `Sende Update f√ºr ${topic}...`, classes: 'blue' });
    }

    function triggerButton(topic, button) {
      if (!ws || ws.readyState !== WebSocket.OPEN) {
        M.toast({ html: 'WebSocket nicht verbunden', classes: 'red' });
        return;
      }
      const msg = { action: 'button_trigger', topic, button };
      console.log('[Button] Triggering:', msg);
      ws.send(JSON.stringify(msg));
      M.toast({ html: `Button "${button}" ausgel√∂st...`, classes: 'blue' });
    }

    // --- WebSocket handling ---
    function connectWs() {
      const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const url = `${protocol}//${window.location.host}/ws`;
      ws = new WebSocket(url);

      ws.onopen = () => {
        byId('wsBadge').textContent = 'WS: verbunden';
        byId('wsBadge').className = 'chip connected';
      };

      ws.onclose = () => {
        byId('wsBadge').textContent = 'WS: getrennt';
        byId('wsBadge').className = 'chip disconnected';
        setTimeout(connectWs, 2000);
      };

      ws.onerror = () => {
        byId('wsBadge').textContent = 'WS: Fehler';
        byId('wsBadge').className = 'chip red lighten-4';
      };

      ws.onmessage = (ev) => {
        // Debug-Ausgabe
        const debugLog = document.getElementById('wsDebugLog');
        if (debugLog) {
          const timestamp = new Date().toLocaleTimeString('de-DE');
          debugLog.textContent += `[${timestamp}] ‚Üê ${ev.data}\n`;
          debugLog.scrollTop = debugLog.scrollHeight;
        }

        try {
          const msg = JSON.parse(ev.data);
          
          // Handle graph_point messages
          if (msg.topic === 'graph_point' && msg.data) {
            handleGraphPoint(msg.data);
            return;
          }
          
          if (!msg.topic) return;
          topicState[msg.topic] = msg.data || {};
          renderTopics();
        } catch (e) {
          console.error('WS parse error', e);
        }
      };
    }

    // --- Graph rendering ---
    function renderGraph(topic, key, graphData) {
      const graphName = graphData.graph || 'unknown';
      const label = graphData.label || key;
      const maxCount = graphData.max_count || 60;
      
      // Get or create graph container
      let graphContainer = byId(`graph-${graphName}`);
      if (!graphContainer) {
        graphContainer = document.createElement('div');
        graphContainer.id = `graph-${graphName}`;
        graphContainer.className = 'card';
        graphContainer.style.marginTop = '1rem';
        
        const content = document.createElement('div');
        content.className = 'card-content';
        
        const title = document.createElement('span');
        title.className = 'card-title';
        title.textContent = `üìä ${formatTopic(graphName)}`;
        content.appendChild(title);
        
        const chartWrapper = document.createElement('div');
        chartWrapper.style.position = 'relative';
        chartWrapper.style.height = '200px';
        chartWrapper.style.width = '100%';
        
        const canvas = document.createElement('canvas');
        canvas.id = `chart-${graphName}`;
        chartWrapper.appendChild(canvas);
        content.appendChild(chartWrapper);
        
        graphContainer.appendChild(content);
        byId('graphsContainer').appendChild(graphContainer);
        
        // Initialize Chart.js
        const ctx = canvas.getContext('2d');
        graphCharts[graphName] = {
          chart: new Chart(ctx, {
            type: 'line',
            data: {
              labels: [],
              datasets: []
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              animation: { duration: 200 },
              scales: {
                x: { display: true, title: { display: true, text: 'Zeit' } },
                y: { 
                  display: true, 
                  title: { display: true, text: 'Wert' },
                  beginAtZero: false
                }
              },
              plugins: {
                legend: { display: true, position: 'top' }
              }
            }
          }),
          datasets: {},
          maxCount: maxCount
        };
      }
      
      const graphInfo = graphCharts[graphName];
      
      // Update max_count if changed
      if (graphData.max_count) {
        graphInfo.maxCount = graphData.max_count;
      }
      
      // Add or update dataset for this label
      if (!graphInfo.datasets[label]) {
        const colors = ['#4caf50', '#2196f3', '#ff9800', '#e91e63', '#9c27b0', '#00bcd4'];
        const colorIndex = Object.keys(graphInfo.datasets).length % colors.length;
        
        graphInfo.datasets[label] = {
          label: label,
          data: [],
          borderColor: colors[colorIndex],
          backgroundColor: colors[colorIndex] + '20',
          borderWidth: 2,
          tension: 0.3,
          fill: true
        };
        
        graphInfo.chart.data.datasets.push(graphInfo.datasets[label]);
      }
      
      // Load initial values if present
      if (graphData.values && Array.isArray(graphData.values)) {
        const dataset = graphInfo.datasets[label];
        dataset.data = [];
        graphInfo.chart.data.labels = [];
        
        graphData.values.forEach((point, idx) => {
          const timestamp = point.x ? new Date(point.x).toLocaleTimeString('de-DE') : idx.toString();
          if (graphInfo.chart.data.labels.length < graphData.values.length) {
            graphInfo.chart.data.labels.push(timestamp);
          }
          dataset.data.push(point.y);
        });
        
        graphInfo.chart.update();
      }
    }
    
    function handleGraphPoint(data) {
      if (!data.graph || !data.label) return;
      
      const graphName = data.graph;
      const label = data.label;
      const graphInfo = graphCharts[graphName];
      
      if (!graphInfo) {
        console.warn('Graph not initialized:', graphName);
        return;
      }
      
      const timestamp = data.x ? new Date(data.x).toLocaleTimeString('de-DE') : new Date().toLocaleTimeString('de-DE');
      const value = data.y;
      
      // Ensure dataset exists
      if (!graphInfo.datasets[label]) {
        console.warn('Dataset not initialized:', label, 'in graph:', graphName);
        return;
      }
      
      const dataset = graphInfo.datasets[label];
      
      // Add new point
      graphInfo.chart.data.labels.push(timestamp);
      dataset.data.push(value);
      
      // Remove old points if exceeds max_count
      const maxCount = graphInfo.maxCount || 60;
      if (graphInfo.chart.data.labels.length > maxCount) {
        graphInfo.chart.data.labels.shift();
        // Shift data for all datasets
        Object.values(graphInfo.datasets).forEach(ds => {
          if (ds.data.length > maxCount) {
            ds.data.shift();
          }
        });
      }
      
      graphInfo.chart.update();
    }

    // --- HTTP Auth check & login ---
    function fetchStatus() {
      return fetch('/status').then((r) => {
        if (r.status === 401) {
          isAuthorized = false;
          showLogin();
          throw new Error('unauthorized');
        }
        return r.json();
      });
    }

    function handleLogin() {
      const pw = byId('adminPw').value;
      fetch('/admin/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password: pw })
      })
        .then((r) => r.json())
        .then((res) => {
          if (res.ok) {
            isAuthorized = true;
            showMain();
            M.toast({ html: 'Login erfolgreich', classes: 'green' });
          } else {
            M.toast({ html: 'Login fehlgeschlagen', classes: 'red' });
          }
        })
        .catch(() => M.toast({ html: 'Fehler beim Login', classes: 'red' }));
    }

    // --- Dynamic buttons (optional server config) ---
    function loadDynamicButtons() {
      fetch('/admin/ui-config')
        .then((r) => r.json())
        .then((cfg) => {
          const hostCard = byId('dynamicButtons');
          const container = byId('dynamicButtonsContainer');
          container.innerHTML = '';
          if (!cfg || !Array.isArray(cfg.buttons) || !cfg.buttons.length) {
            hostCard.style.display = 'none';
            return;
          }
          hostCard.style.display = 'block';
          cfg.buttons.forEach((btn) => {
            const a = document.createElement('a');
            a.className = 'btn';
            a.style.margin = '0.25rem';
            a.textContent = btn.label || btn.id || 'Action';
            a.onclick = () => {
              const run = () => {
                fetch(btn.path, { method: btn.method || 'GET' })
                  .then((r) => {
                    if (!r.ok) throw new Error('request failed');
                    M.toast({ html: `${a.textContent} ausgef√ºhrt`, classes: 'green' });
                  })
                  .catch(() => M.toast({ html: 'Fehler', classes: 'red' }));
              };
              if (btn.confirm) {
                if (confirm(btn.confirm === true ? 'Ausf√ºhren?' : btn.confirm)) run();
              } else {
                run();
              }
            };
            container.appendChild(a);
          });
        })
        .catch(() => {});
    }

    // --- Init ---
    document.addEventListener('DOMContentLoaded', () => {
      connectWs();
      loadDynamicButtons();

      byId('loginBtn').onclick = handleLogin;

      fetchStatus()
        .then(() => {
          isAuthorized = true;
          showMain();
        })
        .catch((err) => {
          if (err.message !== 'unauthorized') {
            console.warn('Status konnte nicht geladen werden', err);
          }
        });
    });
  </script>
</body>

</html>