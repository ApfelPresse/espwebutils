<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>ESP32 Graphen</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href="/css/materialize.min.css" rel="stylesheet" />
  <link href="/css/material-icons.css" rel="stylesheet" />

  <style>
    body { padding: 2rem; }
    .graph-card { margin-bottom: 1.5rem; }
    .graph-canvas { width: 100%; height: 300px; }
  </style>

  <script src="/js/chart.umd.min.js"></script>
</head>

<body>
  <h4>ðŸ“ˆ Live Graphen</h4>
  <div id="graphs"></div>

  <script src="/js/materialize.min.js"></script>
  <script>
    const graphsContainer = document.getElementById("graphs");
    const charts = new Map();

    // ---- Debug ----
    const DBG = true;
    const log = (...a) => DBG && console.log("[graphs]", ...a);
    const warn = (...a) => DBG && console.warn("[graphs]", ...a);
    const err  = (...a) => DBG && console.error("[graphs]", ...a);

    log("Browser TZ:", Intl.DateTimeFormat().resolvedOptions().timeZone);
    log("Browser locale:", navigator.language);

    // Sekunden (10-stellig) oder ms (13-stellig) -> immer ms
    function toMsAuto(x) {
      const n = Number(x);
      if (!Number.isFinite(n)) return NaN;
      return (n < 1e12) ? n * 1000 : n;
    }

    // alles vor 2001 rauswerfen (verhindert init x=5 => 1970)
    function isPlausibleEpochMs(ms) {
      return Number.isFinite(ms) && ms >= 978307200000; // 2001-01-01
    }

    function ensureGraph(graphName) {
      if (charts.has(graphName)) return charts.get(graphName);

      const card = document.createElement("div");
      card.className = "card graph-card";

      const content = document.createElement("div");
      content.className = "card-content";

      const title = document.createElement("span");
      title.className = "card-title";
      title.textContent = graphName;

      const canvas = document.createElement("canvas");
      canvas.className = "graph-canvas";

      content.appendChild(title);
      content.appendChild(canvas);
      card.appendChild(content);
      graphsContainer.appendChild(card);

      const ctx = canvas.getContext("2d");
      const chart = new Chart(ctx, {
        type: "line",
        data: { datasets: [] },
        options: {
          responsive: true,
          animation: false,
          parsing: false,
          normalized: true,
          interaction: { mode: "nearest", intersect: true },
          plugins: {
            legend: { display: true },
            tooltip: {
              enabled: true,
              callbacks: {
                title: (items) => {
                  if (!items || !items.length) return "";
                  const ms = Number(items[0].parsed.x);
                  if (!Number.isFinite(ms)) return "";
                  return new Date(ms).toLocaleString();
                },
                label: (context) => {
                  const lab = context.dataset?.label ?? "";
                  const y = (context.parsed?.y != null) ? context.parsed.y : context.formattedValue;
                  return `${lab}: ${y}`;
                }
              }
            }
          },
          scales: {
            x: {
              type: "linear",
              title: { display: true, text: "Zeit" },
              ticks: {
                callback: (value) => {
                  const ms = Number(value);
                  if (!Number.isFinite(ms)) return value;
                  return new Date(ms).toLocaleTimeString();
                }
              }
            },
            y: { title: { display: true, text: "Wert" } }
          }
        }
      });

      const obj = { chart, datasets: new Map() };
      charts.set(graphName, obj);
      log("Created graph:", graphName);
      return obj;
    }

    function ensureDataset(graphName, label) {
      const g = ensureGraph(graphName);
      if (g.datasets.has(label)) return g.datasets.get(label);

      const datasetIndex = g.chart.data.datasets.length;
      g.chart.data.datasets.push({
        label,
        data: [],
        borderWidth: 2,
        pointRadius: 0
      });

      g.datasets.set(label, datasetIndex);
      log("Created dataset:", { graphName, label, datasetIndex });
      return datasetIndex;
    }

    function setSeries(graphName, label, points) {
      const g = ensureGraph(graphName);
      const idx = ensureDataset(graphName, label);

      const mapped = (points || [])
        .map(p => ({ x: toMsAuto(p.x), y: Number(p.y) }))
        .filter(p => Number.isFinite(p.x) && Number.isFinite(p.y))
        .filter(p => isPlausibleEpochMs(p.x));   // <<< WICHTIG!

      if ((points || []).length && mapped.length === 0) {
        warn("Init points dropped (implausible timestamps).", { graphName, label, sample: points?.[0] });
      }

      g.chart.data.datasets[idx].data = mapped;
      g.chart.update("none");

      log("Set series:", { graphName, label, pointsIn: (points || []).length, pointsUsed: mapped.length });
    }

    function appendPoint(graphName, label, x, y) {
      const g = ensureGraph(graphName);
      const idx = ensureDataset(graphName, label);
      const arr = g.chart.data.datasets[idx].data;

      const ms = toMsAuto(x);
      const yy = Number(y);

      if (!Number.isFinite(ms) || !Number.isFinite(yy)) {
        warn("appendPoint ignored (non-finite)", { graphName, label, x, y });
        return;
      }

      // optional: auch live-points filtern (falls mal wieder x=0 kommt)
      if (!isPlausibleEpochMs(ms)) {
        warn("appendPoint dropped (implausible timestamp)", { graphName, label, x, ms });
        return;
      }

      arr.push({ x: ms, y: yy });
      while (arr.length > 20) arr.shift();
      g.chart.update("none");

      // weniger Spam: nur alle 10 Punkte loggen
      if (arr.length % 10 === 0) {
        const last = arr[arr.length - 1];
        log("Last point:", { graphName, label, time: new Date(last.x).toLocaleString(), y: last.y, len: arr.length });
      }
    }

    // ---- WebSocket ----
    const proto = (location.protocol === "https:") ? "wss" : "ws";
    const wsUrl = `${proto}://${location.host}/ws/graphs`;
    log("WS URL:", wsUrl);

    const ws = new WebSocket(wsUrl);

    ws.onopen  = () => { log("WS open"); try { M.toast({ html: "WebSocket verbunden", classes: "green" }); } catch(e) {} };
    ws.onclose = (ev) => { warn("WS close", { code: ev.code, reason: ev.reason }); try { M.toast({ html: "WebSocket getrennt", classes: "red" }); } catch(e) {} };
    ws.onerror = (e) => err("WS error", e);

    ws.onmessage = (ev) => {
      let msg;
      try { msg = JSON.parse(ev.data); }
      catch (e) { err("JSON parse failed", e, ev.data); return; }

      if (msg.type === "init") {
        setSeries(msg.graph, msg.label, msg.points || []);
      } else if (msg.type === "data") {
        appendPoint(msg.graph, msg.label, msg.x, msg.y);
      } else if (msg.type === "init_done") {
        log("init_done");
      }
    };
  </script>
</body>
</html>
